### **IP-адрес**
Уникальный числовой идентификатор устройства в сети. Состоит из 4 чисел (от 0 до 255), разделённых точками.
**Пример:** `192.168.1.10`
### **Маска сети**
Определяет, какая часть IP относится к адресу сети, а какая — к адресу устройства. Единицы (1) — часть сети, нули (0) — часть устройства.
**Пример:** `255.255.255.0` = `/24`
### **Адрес сети**
Первый адрес в диапазоне. Получается поразрядной конъюнкцией IP и маски. Нельзя назначать устройствам.
**Пример:** Для `192.168.1.10/24` адрес сети = `192.168.1.0`
### **strict=False**
Параметр в `ip_network()`, позволяющий использовать любой IP из сети, а не только точный адрес сети.
```python
ip_network('192.168.1.1/24', strict=False)  # Работает
ip_network('192.168.1.1/24')                # Ошибка
```

## Алгоритм решения задач

### **Шаг 1: Анализ условия**
- **Пример задачи 1:** "Сколько в этой сети IP-адресов..." → решаем кодом
- **Пример задачи 2:** "Чему равно наибольшее возможное значение третьего слева байта маски?" → решаем кодом или вручную через двоичную систему

### **Шаг 2: Решение кодом** (для задачи типа "сколько адресов")
```python
from ipaddress import *

# 2.1 Если дан IP и маска → создаём сеть
# Пример для задачи: Сеть задана IP-адресом 123.222.111.192 и маской сети 255.255.255.248
net = ip_network('123.222.111.192/255.255.255.248', strict=False)
count = 0

# 2.2 Перебираем все адреса в сети
for ip in net:
    # Берём четвёртый байт (последнее число)
    fourth_byte = int(str(ip).split('.')[-1])
    
    # Считаем единицы в двоичной записи четвёртого байта
    ones = bin(fourth_byte).count('1')
    
    # Проверяем условие: не делится на 3
    if ones % 3 != 0:
        count += 1

print(count)  # Выводим ответ
```

### **Шаг 3: Решение вручную** (для задачи типа "значение байта маски")
**Пример задачи:** Для узла с IP-адресом 215.181.200.27 адрес сети равен 215.181.192.0. Чему равно наибольшее возможное значение третьего слева байта маски?

1. **Переводим байты в двоичную систему:**
   ```
   IP:    200₁₀ = 1100 1000₂
   Сеть:  192₁₀ = 1100 0000₂
   ```

2. **Сравниваем биты IP и адреса сети:**
   ```
   IP:     1 1 0 0 1 0 0 0
   Сеть:   1 1 0 0 0 0 0 0
   ```

3. **Определяем, где должны быть единицы/нули в маске:**
   - Первые 4 бита совпадают (1100) → в маске здесь должны быть единицы
   - 5-й бит: IP=1, Сеть=0 → здесь в маске должен быть 0
   - Остальные биты: в маске нули

   Получаем: `1111 0000₂`

4. **Переводим результат обратно в десятичную систему:**
   ```
   1111 0000₂ = 240₁₀
   ```

**Ответ:** 240

## Типовые задачи с решениями

### **Тип 1: Найти характеристику маски по IP и адресу сети**
```python
# Задача: Для узла с IP-адресом 111.91.200.28 адрес сети равен 111.91.192.0. 
# Найдите наименьшее возможное количество нулей в двоичной записи маски.

from ipaddress import *

ip = ip_address('111.91.200.28')
net = ip_address('111.91.192.0')
min_zeros = 32

for mask_len in range(33):
    network = ip_network(f'{ip}/{mask_len}', strict=False)
    if network.network_address == net:
        zeros = 32 - mask_len
        if zeros < min_zeros:
            min_zeros = zeros

print(min_zeros)
```

### **Тип 2: Найти значение байта маски**
```python
# Задача: Для узла с IP-адресом 111.81.27.208 адрес сети равен 111.81.27.192.
# Чему равно наименьшее возможное значение последнего байта маски?

from ipaddress import *

ip = ip_address('111.81.27.208')
net = ip_address('111.81.27.192')
min_byte = 256

for mask_len in range(33):
    network = ip_network(f'{ip}/{mask_len}', strict=False)
    if network.network_address == net:
        mask = network.netmask
        last_byte = int(str(mask).split('.')[-1])
        if last_byte < min_byte:
            min_byte = last_byte

print(min_byte)
```

### **Тип 3: Подсчёт адресов с определённым свойством**
```python
# Задача: Сеть задана IP-адресом 122.159.136.144 и маской 255.255.255.248.
# Сколько в этой сети IP-адресов, для которых количество единиц в двоичной записи 
# IP-адреса не кратно 4?

from ipaddress import *

net = ip_network('122.159.136.144/255.255.255.248', strict=False)
count = 0

for ip in net:
    ones = bin(int(ip)).count('1')
    if ones % 4 != 0:
        count += 1

print(count)
```

### **Тип 4: Анализ конкретного байта** (реализация шага 2)
```python
# Задача: Сеть задана IP-адресом 123.222.111.192 и маской 255.255.255.248.
# Сколько в этой сети IP-адресов, для которых сумма единиц в двоичной записи 
# четвёртого байта IP-адреса не делится без остатка на 3?

from ipaddress import *

net = ip_network('123.222.111.192/255.255.255.248', strict=False)
count = 0

for ip in net:
    fourth_byte = int(str(ip).split('.')[-1])
    ones = bin(fourth_byte).count('1')
    if ones % 3 != 0:
        count += 1

print(count)
```

### **Тип 5: Поиск паттерна в двоичной записи**
```python
# Задача: Сеть задана IP-адресом 136.36.240.16 и маской 255.255.255.248.
# Сколько в этой сети IP-адресов, в которых в двоичной записи IP-адреса не встречается 101?

from ipaddress import *

net = ip_network('136.36.240.16/255.255.255.248', strict=False)
count = 0

for ip in net:
    bin_str = bin(int(ip))[2:].zfill(32)
    if '101' not in bin_str:
        count += 1

print(count)
```

### **Тип 6: Исключение служебных адресов**
```python
# Задача: Сеть задана IP-адресом 192.168.63.0 и маской 255.255.255.128.
# Сколько в этой сети IP-адресов, для которых количество нулей в двоичной записи 
# IP-адреса не кратно 5? (без адреса сети и широковещательного)

from ipaddress import *

net = ip_network('192.168.63.0/255.255.255.128', strict=False)
count = 0

for ip in net:
    if ip == net.network_address or ip == net.broadcast_address:
        continue
    zeros = bin(int(ip))[2:].zfill(32).count('0')
    if zeros % 5 != 0:
        count += 1

print(count)
```

### **Тип 7: Поиск наибольшего/наименьшего адреса**
```python
# Задача: Сеть задана IP-адресом 10.15.179.18 и маской 255.255.254.0.
# Найдите наибольший IP-адрес, который может быть назначен компьютеру.
# В ответе укажите сумму байтов найденного IP-адреса.

from ipaddress import *

net = ip_network('10.15.179.18/255.255.254.0', strict=False)
max_ip = net.broadcast_address - 1
sum_bytes = sum(map(int, str(max_ip).split('.')))
print(sum_bytes)
```

### **Тип 8: Сети с разными/одинаковыми масками**
```python
# Задача: Два узла, находящиеся в разных подсетях, имеют IP-адреса 
# 151.172.115.121 и 151.172.115.156. В масках одинаковое количество единиц.
# Укажите наименьшее возможное количество единиц в масках.

from ipaddress import *

ip1 = ip_address('151.172.115.121')
ip2 = ip_address('151.172.115.156')
min_ones = 32

for mask_len in range(33):
    net1 = ip_network(f'{ip1}/{mask_len}', strict=False)
    net2 = ip_network(f'{ip2}/{mask_len}', strict=False)
    if net1.network_address != net2.network_address:
        if mask_len < min_ones:
            min_ones = mask_len

print(min_ones)
```

### **Тип 9: Минимальный размер сети**
```python
# Задача: Два узла, находящиеся в одной сети, имеют IP-адреса 
# 121.171.5.70 и 121.171.5.107. Укажите наименьшее возможное количество адресов в этой сети.

from ipaddress import *

ip1 = ip_address('121.171.5.70')
ip2 = ip_address('121.171.5.107')
min_hosts = 2**32

for mask_len in range(33):
    net1 = ip_network(f'{ip1}/{mask_len}', strict=False)
    net2 = ip_network(f'{ip2}/{mask_len}', strict=False)
    if net1.network_address == net2.network_address:
        hosts = net1.num_addresses
        if hosts < min_hosts:
            min_hosts = hosts

print(min_hosts)
```

## Полезные функции

### **Преобразования**
```python
# IP → двоичная строка (32 бита)
bin_str = bin(int(ip))[2:].zfill(32)

# IP → список байтов
bytes_list = str(ip).split('.')  # ['192', '168', '1', '1']

# Байт → количество единиц
ones = bin(byte).count('1')

# Сумма байтов IP
sum_bytes = sum(map(int, str(ip).split('.')))
```

### **Проверки**
```python
# Принадлежность адреса сети
ip in net  # True/False

# Служебные адреса
ip == net.network_address      # Адрес сети
ip == net.broadcast_address    # Широковещательный адрес
```

## Краткий чеклист
1. Импортируй `from ipaddress import *`
2. Определи тип задачи (подсчёт, поиск значения, сравнение сетей)
3. Создай объекты (`ip_address`, `ip_network`)
4. Используй `strict=False` для удобства
5. Перебирай адреса (`for ip in net`) или маски (`for mask_len in range(33)`)
6. Проверяй условие и считай
7. Не забудь про служебные адреса (если нужно)
8. Выводи ответ