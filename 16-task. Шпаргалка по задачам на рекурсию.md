# Шпаргалка по задачам на рекурсию в Python

## Основные понятия

- **Рекурсия** — вызов функцией самой себя для решения подзадач
- **Глубина рекурсии** — количество вложенных вызовов функции до достижения базового случая
- **База рекурсии** — условие прекращения рекурсии, когда задача решается напрямую
- **Итеративное решение** — решение с использованием циклов вместо рекурсии
- **Наивное решение** — простой подход без оптимизации, часто неэффективный
- **Мемоизация** — сохранение результатов вычислений для повторного использования
## Алгоритм действий

### **Шаг 1: Определяем базу рекурсии**
Смотрим на условие и определяем, когда функция перестаёт вызывать себя.

**Пример задачи:**  
Алгоритм вычисления значения функции $F(n)$, где $n$ — натуральное число, задан так:
$F(n) = 1$ при $n \geq 2025$
$F(n) = n - F(n + 2) - F(n + 4)$, если $n < 2025$

**База:** при $n \geq 2025$
### **Шаг 2: Реализуем функцию**
```python
def F(n):
    if n >= 2025:
        return 1
    else:
        return n - F(n + 2) - F(n + 4)
```
### **Шаг 3: Импортируем декоратор и кешируем**
```python
from functools import lru_cache

@lru_cache(1000)  # храним последнюю тысячу значений
def F(n):
    if n >= 2025:
        return 1
    else:
        return n - F(n + 2) - F(n + 4)
```
### **Шаг 4: Предварительный расчёт значений**
```python
for i in range(10, 15900):
    F(i)  # Заполняем кеш
```
### **Шаг 5: Считаем ответ**
```python
print(F(20) + F(25))
```
## Варианты задач

### **1. Две функции в одной задаче**

**Задача:**  
Алгоритм вычисления значения функции $F(n)$ и $G(n)$, где $n$ — целое число, задан следующими соотношениями:
$F(n) = 2 \times (G(n - 3) + 8)$
$G(n) = 2 \times n$, если $n < 10$
$G(n) = G(n - 2) + 1$, если $n \geq 10$
Чему равно значение выражения $F(15548)$?

**Решение:**
```python
from functools import lru_cache

@lru_cache(1000)
def G(n):
    if n < 10:
        return 2 * n
    else:
        return G(n - 2) + 1

@lru_cache(1000)
def F(n):
    return 2 * (G(n - 3) + 8)

# Заполняем кеш для обеих функций
for i in range(10, 15900):
    F(i)
    G(i)

print(F(15548))
```
### **2. Сложная база (большие вычисления)**

**Задача:**  
Алгоритм вычисления значения функции $F(n)$, где $n$ — натуральное число, задан так:
$F(n) = n^{(n^2)}$ при $n \leq 1000$;
$F(n) = n + 2F(n - 2) + 6F(n - 6)$ при $n > 1000$.
Чему равно значение выражения $F(20024) - 2F(20022) - 3F(20020) + 18F(20014)$?

**Важное наблюдение:**  
При $n > 1000$ значение $F(n)$ зависит только от предыдущих значений через линейную комбинацию. Следовательно, ответ **не зависит** от конкретных значений на базе $n \leq 1000$. Можно заменить сложное вычисление на любое константное значение.

**Решение:**
```python
from functools import lru_cache

@lru_cache(1000)
def F(n):
    if n <= 1000:
        # Возвращаем 0 — ответ не зависит от этого значения
        return 0
    else:
        return n + 2 * F(n - 2) + 6 * F(n - 6)

# Заполняем кеш для больших значений
for i in range(1000, 20024):
    F(i)

result = F(20024) - 2 * F(20022) - 3 * F(20020) + 18 * F(20014)
print(result)
```
### **3. Подсчёт количества вызовов (или печатаемых символов)**

**Задача:**  
Яндекс Учебник  
Ниже записана рекурсивная функция:
```python
def f(n):
    print('*')
    if n >= 1:
        print('*')
        f(n - 1)
        f(n // 2)
```
Сколько символов «звёздочка» будет напечатано на экране при выполнении вызова f(40)?

**Решение:**
```python
from functools import lru_cache

counter = 0  # глобальный счётчик

@lru_cache(1000)
def f(n):
    global counter
    counter += 1  # первый print('*')
    
    if n >= 1:
        counter += 1  # второй print('*')
        f(n - 1)
        f(n // 2)
    
    return counter  # возвращаем счётчик для кеширования

# Вызываем функцию
f(40)
print(counter)
```
## Типовой шаблон решения

```python
from functools import lru_cache

# 1. Определяем функцию с кешированием
@lru_cache(1000)
def F(n):
    # База рекурсии
    if условие_базы:
        return базовое_значение
    # Рекурсивный случай
    else:
        return выражение_с_F

# 2. Предварительно заполняем кеш (чтобы избежать рекурсивного переполнения стека)
#    Диапазон подбирается по условию задачи
for i in range(минимальное_n, максимальное_n + 1):
    F(i)

# 3. Вычисляем требуемое выражение
print(выражение_с_F)
```
## Ключевые моменты

1. **Всегда используй `@lru_cache`** — без кеширования вычисления будут экспоненциально медленными.
2. **Определите правильную базу рекурсии** — ошибка в базе приведёт к бесконечной рекурсии или неверному ответу.
3. **Предварительный расчёт** — для больших `n` полезно заранее вычислить значения в цикле, чтобы избежать глубокой рекурсии.
4. **Анализ зависимости** — в задачах со сложной базой (типа $n^{(n^2)}$) часто ответ не зависит от точного значения на базе. Проверьте, является ли рекуррентное соотношение линейным.
5. **Глобальные переменные** — используй для подсчёта вызовов, печати или других побочных эффектов.
6. **Две функции** — если в задаче две взаимозависимые функции, кешируй обе и предварительно вычисляй значения для обеих.

## Чек-лист решения

- [ ] Прочитал условие, понял базу рекурсии
- [ ] Написал функцию с `@lru_cache`
- [ ] Указал правильные условия в if-else
- [ ] Добавил предварительный расчёт значений (диапазон по условию задачи)
- [ ] Вычислил требуемое выражение
- [ ] Проверил на небольших значениях (если возможно)

## Частые ошибки

1. **Забыть `@lru_cache`** — программа «зависает» даже на небольших `n`.
2. **Неправильная база** — например, написать `n <= 2025` вместо `n >= 2025`.
3. **Не предварить расчёт** — для `n = 20000` рекурсия без предрасчёта может переполнить стек вызовов.
4. **Использовать сложные вычисления на базе** — если ответ не зависит от них, заменяйте на константу для скорости.